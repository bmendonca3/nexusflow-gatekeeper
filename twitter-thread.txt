================================================================================
PROJECT CONTEXT
================================================================================
What is NexusFlow Gatekeeper?

A Cyber-Physical Digital Twin that demonstrates:
â€¢ Real-time distributed state synchronization across multiple clients
â€¢ A "Healer Protocol" - reliable messaging with ACK loops, retries, and deduplication
â€¢ Chaos engineering controls to test system resilience under network failures

Why did I build it?
To prove AI coding assistants (MiniMax) can build complex, production-ready distributed systems - not just simple todo apps.

The Automation (E2E Flow):
1. Playwright E2E tests verify state sync across Commander and Observer clients
2. Tests simulate emergency triggers and verify propagation
3. MCP Vision (MiniMax) analyzes screenshots to verify visual state changes
4. CI/CD pipeline runs automated tests on every push
5. Tests run in parallel contexts to simulate real distributed systems

The Stack:
â€¢ React + React Flow (digital twin visualization)
â€¢ Zustand + zustand-persist (state management)
â€¢ BroadcastChannel + WebSocket (dual transport layer)
â€¢ Playwright + MCP Vision (E2E testing with AI verification)
â€¢ TypeScript strict mode (production-ready code)
â€¢ GitHub Actions CI/CD

================================================================================
TWEET 1 (Hook)
================================================================================
I built a Cyber-Physical Digital Twin dashboard with MiniMax ðŸŽ¯

[dashboard-normal.png]

5 robot nodes. Real-time state sync. Chaos engineering controls.

Here's how it went ðŸ§µ

================================================================================
TWEET 2 (The Prompt)
================================================================================
Started with a simple prompt:

"Build a React dashboard with React Flow showing 5 robots. When I click a button, one robot changes color."

MiniMax generated the whole scaffold in 30 seconds.

================================================================================
TWEET 3 (The Architecture)
================================================================================
Then I got ambitious.

"Add a Healer Protocol with ACK loop, retry logic, and duplicate detection."

MiniMax wrote the reliable messaging layer.

================================================================================
TWEET 4 (The Code)
================================================================================
The Healer Protocol (ACK Loop):

// 1. Track pending messages
const pendingMessages = new Map();
pendingMessages.set(message.id, {
  message,
  acknowledged: false,
  lastAttempt: Date.now(),
  attempts: 0,
});

// 2. Retry loop runs every 300ms
setInterval(() => {
  pendingMessages.forEach((pending, messageId) => {
    if (pending.acknowledged) return;

    // Check timeout
    if (now - pending.lastAttempt < ACK_TIMEOUT_MS) return;

    // Max retries exceeded?
    if (pending.attempts >= MAX_RETRY_ATTEMPTS) {
      pending.acknowledged = true; // Give up
      return;
    }

    // Retry
    sendViaTransport(pending.message);
    pending.attempts++;
    pending.lastAttempt = Date.now();
  });
}, ACK_TIMEOUT_MS);

// 3. Receiver sends ACK + deduplication
if (appliedMessageIds.has(message.id)) {
  sendAck(message.id); // Already seen, resend ACK
  return true;
}
applyMessage(message);
appliedMessageIds.add(message.id);
sendAck(message.id);

Sender: [msg] â†’ wait(ACK) â†’ retry if timeout
Receiver: apply â†’ [ACK] â†’ track ID (dedup)
Both: interval loop checks pending messages

================================================================================
TWEET 5 (The Visuals)
================================================================================
[dashboard-emergency.png]

Click "Emergency" â†’ Robot turns red â†’ State synced across all clients via BroadcastChannel or WebSocket

The "Healer Protocol" ensures every state change is acknowledged.

================================================================================
TWEET 6 (The Chaos)
================================================================================
"Add chaos engineering - packet loss and latency simulation"

Now I can test how the ACK loop handles network failures in real-time.

Controls:
â€¢ Packet loss rate (0-100%)
â€¢ Min/Max latency (ms)

Perfect for testing resilience.

================================================================================
TWEET 7 (The Reality Check)
================================================================================
It wasn't all smooth.

â€¢ Map/Set serialization broke TypeScript strict mode
â€¢ Truncated test files from a bad merge
â€¢ Multiple iteration prompts to fix type errors

AI helps. You still need to debug.

================================================================================
TWEET 8 (The Result)
================================================================================
1,500+ lines of TypeScript:
â€¢ Zustand store with persistence
â€¢ Dual transport (BroadcastChannel + WebSocket)
â€¢ Full Playwright E2E tests
â€¢ CI/CD with passing builds

Built in days with MiniMax. Not weeks.

GitHub: https://github.com/bmendonca3/nexusflow-gatekeeper

================================================================================
IMAGES NEEDED:
================================================================================
â€¢ dashboard-normal.png (screenshot of dashboard in normal state)
â€¢ dashboard-emergency.png (screenshot with Robot-Alpha in red/emergency state)

Both in: /Users/brianmendonca/.playwright-mcp/

================================================================================
POSTING TIPS:
================================================================================
â€¢ Post one tweet every 1-2 hours
â€¢ Include the image with each relevant tweet
â€¢ Engage with replies (like, reply)
â€¢ The thread will automatically link together

================================================================================
